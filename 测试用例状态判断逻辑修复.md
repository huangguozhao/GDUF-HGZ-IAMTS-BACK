# 测试用例状态判断逻辑修复

## 问题描述

执行接口测试时，虽然有测试用例的所有断言都通过了，但仍然被标记为"failed"：

- ✅ **空用户名测试**：期望400 + "用户名不能为空"，实际也是这样 → 断言全部通过
- ✅ **空密码测试**：期望400 + "密码不能为空"，实际也是这样 → 断言全部通过
- ❌ **但系统将这些标记为"失败"**

## 根本原因

在`TestCaseExecutor.determineExecutionStatus()`方法中，原来的逻辑是：

```java
private ExecutionStatusEnum determineExecutionStatus(HttpClientUtils.HttpResponseResult response, 
                                                    List<AssertionUtils.AssertionResult> assertionResults) {
    // ❌ 错误：先检查HTTP状态码
    if (!response.isSuccess()) {
        return ExecutionStatusEnum.FAILED;
    }

    // 然后才检查断言结果
    if (assertionResults != null && !assertionResults.isEmpty()) {
        for (AssertionUtils.AssertionResult result : assertionResults) {
            if (!result.isPassed()) {
                return ExecutionStatusEnum.FAILED;
            }
        }
    }

    return ExecutionStatusEnum.PASSED;
}
```

**问题：**
- 只要HTTP状态码不是2xx（比如400、401、500等），就直接返回`FAILED`
- 完全不考虑断言结果
- 导致测试"失败场景"时，即使断言全部通过，也会被标记为失败

## 核心理念

**测试用例的"通过/失败"应该基于断言结果，而不是业务结果或HTTP状态码！**

| 场景 | HTTP状态码 | 断言结果 | 测试状态 | 说明 |
|------|-----------|---------|---------|------|
| 正常登录成功 | 200 | 3个断言全通过 | ✅ passed | 业务成功，断言通过 |
| 空用户名登录 | 400 | 3个断言全通过 | ✅ passed | 业务失败，但断言通过（预期就是400） |
| 空密码登录 | 400 | 3个断言全通过 | ✅ passed | 业务失败，但断言通过（预期就是400） |
| 密码错误登录 | 200 | 断言失败（msg不匹配） | ❌ failed | 业务返回成功，但断言失败 |

## 修复方案

修改`TestCaseExecutor.determineExecutionStatus()`方法：

```java
/**
 * 判断执行状态
 * 
 * 重要：测试用例的通过/失败只看断言结果，不看业务结果或HTTP状态码
 * - 如果所有断言都通过 → 测试状态 = passed（即使HTTP返回4xx/5xx或业务失败）
 * - 如果有任何断言失败 → 测试状态 = failed
 * - 如果没有断言 → 只要请求成功就是passed
 */
private ExecutionStatusEnum determineExecutionStatus(HttpClientUtils.HttpResponseResult response, 
                                                    List<AssertionUtils.AssertionResult> assertionResults) {
    // 1. 如果有断言，只看断言结果
    if (assertionResults != null && !assertionResults.isEmpty()) {
        for (AssertionUtils.AssertionResult result : assertionResults) {
            if (!result.isPassed()) {
                return ExecutionStatusEnum.FAILED;
            }
        }
        // 所有断言都通过
        return ExecutionStatusEnum.PASSED;
    }
    
    // 2. 如果没有断言，检查HTTP请求是否成功
    // 注意：这里的success指的是请求成功发送并收到响应，不是业务成功
    if (response.isSuccess() || response.getStatusCode() > 0) {
        // 只要收到了HTTP响应（无论是2xx、4xx还是5xx），就认为测试通过
        return ExecutionStatusEnum.PASSED;
    }

    // 3. 只有在网络错误、超时等情况下才算失败
    return ExecutionStatusEnum.FAILED;
}
```

## 逻辑说明

### 1. 有断言的情况（推荐）

**只看断言结果，不管HTTP状态码或业务结果**

```java
if (assertionResults != null && !assertionResults.isEmpty()) {
    // 遍历所有断言
    for (AssertionUtils.AssertionResult result : assertionResults) {
        if (!result.isPassed()) {
            return ExecutionStatusEnum.FAILED;  // 任何一个断言失败 → 测试失败
        }
    }
    return ExecutionStatusEnum.PASSED;  // 所有断言通过 → 测试通过
}
```

**示例：**
- 测试"空用户名登录失败"场景
- 断言1：`$.code = 400` ✓ 通过
- 断言2：`$.msg = "用户名不能为空"` ✓ 通过
- **结果：测试 = passed**（虽然HTTP返回400，但这正是我们期望的）

### 2. 没有断言的情况

**只要收到HTTP响应就算通过**

```java
if (response.isSuccess() || response.getStatusCode() > 0) {
    return ExecutionStatusEnum.PASSED;
}
```

**原因：**
- 如果没有定义断言，说明只是想测试接口是否可访问
- 只要能收到响应（2xx、4xx、5xx都可以），就说明接口可访问
- 只有在网络错误、连接超时等情况下才算失败

### 3. 网络错误的情况

```java
return ExecutionStatusEnum.FAILED;
```

**只有以下情况才算测试失败：**
- 网络连接失败（Connection refused）
- 请求超时（Timeout）
- 未知主机（Unknown host）
- 其他网络异常

## 测试用例设计建议

### ✅ 推荐做法：定义明确的断言

```json
{
  "caseName": "空用户名登录测试",
  "assertions": [
    {"type": "status_code", "expected": 400},
    {"type": "json_path", "path": "$.code", "expected": "400"},
    {"type": "json_path", "path": "$.msg", "expected": "用户名不能为空"}
  ]
}
```

**结果：**
- HTTP返回400，断言期望400 → ✅ 断言通过
- 响应msg是"用户名不能为空"，断言期望"用户名不能为空" → ✅ 断言通过
- **测试状态 = passed**

### ❌ 不推荐：没有断言

```json
{
  "caseName": "空用户名登录测试",
  "assertions": []
}
```

**问题：**
- 无法验证返回的具体内容是否正确
- 只能知道接口有响应，但不知道响应是否符合预期

## 修改的文件

- **`src/main/java/com/victor/iatms/utils/TestCaseExecutor.java`**
  - 修改`determineExecutionStatus()`方法
  - 改为优先检查断言结果，而不是HTTP状态码

## 验证步骤

1. 重新编译项目
2. 重启应用
3. 执行接口测试
4. 检查结果：

```bash
# 执行测试
curl -X POST "http://localhost:8080/api/apis/1/execute" \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer <token>" \
  -d '{"environment":"dev","executionType":"manual","timeout":30,"async":false,"concurrency":3}'
```

**预期结果：**

```json
{
  "code": 0,
  "msg": "接口测试执行完成",
  "data": {
    "totalCases": 5,
    "passed": 5,        // ← 应该是5个通过，而不是3个
    "failed": 0,        // ← 应该是0个失败，而不是2个
    "successRate": 100.00,
    "caseResults": [
      {
        "caseName": "正常登录测试",
        "status": "passed"
      },
      {
        "caseName": "空用户名登录测试",
        "status": "passed"  // ← 断言全通过，应该是passed
      },
      {
        "caseName": "空密码登录测试",
        "status": "passed"  // ← 断言全通过，应该是passed
      },
      {
        "caseName": "用户名不存在测试",
        "status": "passed"  // ← 断言全通过，应该是passed
      },
      {
        "caseName": "密码错误测试",
        "status": "passed"  // ← 断言全通过，应该是passed
      }
    ]
  }
}
```

## 总结

**核心原则：**

1. **断言优先**：测试用例的状态由断言结果决定，不由HTTP状态码或业务结果决定
2. **业务失败 ≠ 测试失败**：测试"失败场景"时，业务返回失败是正常的，只要符合预期就是测试通过
3. **明确断言**：每个测试用例都应该定义明确的断言，包括期望的HTTP状态码
4. **网络错误**：只有在网络层面出错时（连接失败、超时等），测试才算失败

**修复前后对比：**

| 场景 | 修复前 | 修复后 | 原因 |
|------|-------|-------|------|
| 空用户名（HTTP 400，断言通过） | ❌ failed | ✅ passed | 断言通过，应该是passed |
| 空密码（HTTP 400，断言通过） | ❌ failed | ✅ passed | 断言通过，应该是passed |
| 正常登录（HTTP 200，断言通过） | ✅ passed | ✅ passed | 无变化 |
| 网络错误（Connection refused） | ❌ failed | ❌ failed | 无变化 |

