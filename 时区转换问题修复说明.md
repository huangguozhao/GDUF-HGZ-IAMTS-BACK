# 时区转换问题修复说明

## 问题描述

当使用时间范围查询执行记录时，返回数据为0，即使数据库中确实存在符合条件的数据。

**问题请求示例：**
```
GET /api/execution-records?execution_scope=api&ref_id=1&start_time_begin=2025-10-16T08:22:23.192Z&start_time_end=2025-10-23T08:22:23.192Z
```

**返回结果：**
```json
{
  "total": 0,
  "items": []
}
```

## 问题原因

### 1. 前端发送的是UTC时间

前端使用JavaScript的`toISOString()`方法生成时间字符串：
```javascript
new Date().toISOString()  
// 输出: "2025-10-23T08:22:23.192Z"  ← 带Z后缀，表示UTC时间
```

### 2. 数据库存储的是本地时间

数据库中存储的时间是**本地时间（北京时间，UTC+8）**：
```sql
SELECT start_time FROM TestExecutionRecords WHERE record_id = 132;
-- 结果: 2025-10-23 15:44:05  ← 本地时间，比UTC时间早8小时
```

### 3. Java代码没有转换时区

原代码直接解析ISO时间字符串，没有考虑时区转换：

```java
// ❌ 错误代码
LocalDateTime.parse("2025-10-23T08:22:23.192Z", DateTimeFormatter.ISO_DATE_TIME)
// 问题：直接将UTC时间当作本地时间使用，导致查询条件错误
```

### 4. 时间对比错误

| 时间类型 | 值 | 说明 |
|---------|-----|------|
| 前端发送（UTC） | 2025-10-23 08:22:23 | 前端的本地时间是16:22:23 |
| Java解析后 | 2025-10-23 08:22:23 | ❌ 直接使用，没有转换 |
| 数据库存储 | 2025-10-23 15:44:05 | 本地时间（UTC+8） |
| 查询结果 | 无匹配 | 08:22 < 15:44，查不到数据 |

**正确的应该是：**
```
前端UTC时间: 2025-10-23 08:22:23 (UTC)
    ↓ 转换为北京时间（+8小时）
Java查询条件: 2025-10-23 16:22:23 (本地时间)
    ↓ 与数据库对比
数据库时间: 2025-10-23 15:44:05
    ↓ 结果
15:44 < 16:22 ✓ 匹配成功
```

## 解决方案

### 修改`TestExecutionRecordController.java`

添加时区转换方法：

```java
/**
 * 解析时间参数（支持UTC时间自动转换为本地时间）
 * 
 * @param timeStr 时间字符串，支持：
 *                - UTC时间（带Z后缀）：2025-10-23T08:22:23.192Z
 *                - 本地时间：2025-10-23T16:22:23.192
 * @return 本地时间
 */
private LocalDateTime parseTimeParameter(String timeStr) {
    if (timeStr.endsWith("Z")) {
        // UTC时间，需要转换为本地时间（UTC+8）
        java.time.ZonedDateTime utcTime = java.time.ZonedDateTime.parse(timeStr);
        java.time.ZonedDateTime localTime = utcTime.withZoneSameInstant(java.time.ZoneId.systemDefault());
        return localTime.toLocalDateTime();
    } else {
        // 本地时间，直接解析
        return LocalDateTime.parse(timeStr, DateTimeFormatter.ISO_DATE_TIME);
    }
}
```

### 更新查询方法

在`getExecutionRecords`和`getExecutionStatistics`方法中使用新的解析方法：

```java
// ✅ 正确代码
if (startTimeBeginStr != null && !startTimeBeginStr.isEmpty()) {
    try {
        LocalDateTime startTimeBegin = parseTimeParameter(startTimeBeginStr);
        query.setStartTimeBegin(startTimeBegin);
    } catch (Exception e) {
        return ResponseVO.paramError("开始时间格式错误: " + e.getMessage());
    }
}
```

## 时间转换示例

### 示例1：前端发送UTC时间

**请求：**
```
GET /api/execution-records?start_time_begin=2025-10-23T08:22:23.192Z
```

**处理流程：**
```java
String input = "2025-10-23T08:22:23.192Z";

// 1. 检测到Z后缀，识别为UTC时间
ZonedDateTime utcTime = ZonedDateTime.parse(input);
// utcTime = 2025-10-23T08:22:23.192Z[UTC]

// 2. 转换为系统默认时区（Asia/Shanghai, UTC+8）
ZonedDateTime localTime = utcTime.withZoneSameInstant(ZoneId.systemDefault());
// localTime = 2025-10-23T16:22:23.192+08:00[Asia/Shanghai]

// 3. 提取本地时间
LocalDateTime result = localTime.toLocalDateTime();
// result = 2025-10-23T16:22:23.192

// 4. 用于SQL查询
// WHERE start_time >= '2025-10-23 16:22:23'
```

### 示例2：前端发送本地时间

**请求：**
```
GET /api/execution-records?start_time_begin=2025-10-23T16:22:23.192
```

**处理流程：**
```java
String input = "2025-10-23T16:22:23.192";

// 1. 没有Z后缀，识别为本地时间
LocalDateTime result = LocalDateTime.parse(input, DateTimeFormatter.ISO_DATE_TIME);
// result = 2025-10-23T16:22:23.192

// 2. 直接用于SQL查询
// WHERE start_time >= '2025-10-23 16:22:23'
```

## 验证

### 测试1：查询UTC时间范围内的记录

**请求：**
```bash
curl "http://localhost:8080/api/execution-records?execution_scope=api&ref_id=1&start_time_begin=2025-10-23T07:00:00Z&start_time_end=2025-10-23T09:00:00Z"
```

**转换后的查询条件：**
```
start_time >= '2025-10-23 15:00:00'  (UTC 07:00 + 8小时)
AND start_time <= '2025-10-23 17:00:00'  (UTC 09:00 + 8小时)
```

**数据库记录：**
```
record_id=132, start_time='2025-10-23 15:44:05'
```

**结果：** ✅ 能够查询到数据

### 测试2：查询本地时间范围内的记录

**请求：**
```bash
curl "http://localhost:8080/api/execution-records?execution_scope=api&ref_id=1&start_time_begin=2025-10-23T15:00:00&start_time_end=2025-10-23T17:00:00"
```

**查询条件：**
```
start_time >= '2025-10-23 15:00:00'
AND start_time <= '2025-10-23 17:00:00'
```

**结果：** ✅ 能够查询到数据

## 兼容性

### 支持的时间格式

1. **UTC时间（推荐前端使用）**
   - 格式：`2025-10-23T08:22:23.192Z`
   - 特点：带Z后缀，表示UTC时间
   - 处理：自动转换为本地时间

2. **本地时间**
   - 格式：`2025-10-23T16:22:23.192`
   - 特点：不带Z后缀
   - 处理：直接使用

3. **不支持的格式**
   - ❌ `2025-10-23 16:22:23`（空格分隔）
   - ❌ `2025/10/23 16:22:23`（斜杠分隔）
   - ❌ `1729672943000`（时间戳）

### 前端建议

**JavaScript生成时间字符串：**
```javascript
// ✅ 推荐：使用toISOString()生成UTC时间
const utcTime = new Date().toISOString();
// "2025-10-23T08:22:23.192Z"

// ⚠️ 可用：手动格式化本地时间
const localTime = new Date().toISOString().replace('Z', '');
// "2025-10-23T16:22:23.192"

// ❌ 不推荐：使用时间戳（需要后端额外处理）
const timestamp = new Date().getTime();
// 1729672943000
```

## 相关文件

- **`src/main/java/com/victor/iatms/controller/TestExecutionRecordController.java`**
  - 添加`parseTimeParameter()`方法
  - 更新`getExecutionRecords()`方法
  - 更新`getExecutionStatistics()`方法

## 注意事项

1. **系统时区配置**
   - 确保JVM时区设置正确：`-Duser.timezone=Asia/Shanghai`
   - 或在`application.yml`中配置：`spring.jackson.time-zone: Asia/Shanghai`

2. **数据库时区**
   - MySQL服务器时区应与应用服务器一致
   - 查看时区：`SELECT @@system_time_zone;`

3. **前后端约定**
   - 推荐前端统一使用UTC时间（带Z后缀）
   - 后端自动处理时区转换
   - 返回给前端的时间也应该转换为UTC时间

## 总结

### 问题

前端发送UTC时间，后端没有转换就直接用于数据库查询，导致时间范围不匹配。

### 解决

添加时区转换逻辑，自动识别UTC时间（带Z后缀）并转换为本地时间。

### 结果

- ✅ 支持UTC时间查询
- ✅ 支持本地时间查询
- ✅ 自动时区转换
- ✅ 向后兼容


